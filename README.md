Download Link: https://assignmentchef.com/product/solved-cs344-problem-set-2
<br>
<strong>Make best use of picture in Latex</strong>: If you think some part of your answer is too difficult to type using Latex, you may write that part on paper and scan it as a picture, and then insert that part into Latex as a picture, and finally Latex will compile the picture into the final PDF output. This will make things easier. For instructions of how to insert pictures in Latex, you may refer to the Latex file of our homework 1, which includes several examples of inserting pictures in Latex.

Discussion Group (People with whom you discussed ideas used in your answers if any): Xudong Jiang

I acknowledge and accept the Honor Code. Please type your initials below:

<strong>Signed</strong>: (YC)

<ol>

 <li><strong>Warm up with BST. </strong>(20 points) Beginning with an empty binary search tree, what binary search tree is formed when you insert the following values in the order given? (Values are compared in alphabet order, e.g., <em>A &lt; B</em>)

  <ul>

   <li>W, T, N, J, E, B, A</li>

   <li>W, T, N, A, B, E, J</li>

   <li>A, B, W, J, N, T, E</li>

   <li>N, A, T, E, B, W, J</li>

  </ul></li>

</ol>

Answer:

Figure 1: Question1 Answer.

<ol start="2">

 <li><strong>Red, black, or neither? </strong>(20 points) For each of the unlabeled binary trees, state whether or not it can be the structure of a red-black tree. If so, color the vertices red or black. If not, state which of the red-black tree invariants (1 to 5) cannot be satisfied and provide an explanation.</li>

</ol>

<strong>[We are expecting a YES/NO, and either (1) a valid coloring or (2) a set of violated invariants and a brief explanation. For the colorings, feel free to</strong>

<strong>redraw the trees by hand and insert the image.]</strong>

<ul>

 <li>(5 point) No (c) (5 point) Yes</li>

 <li>(5 point) Yes (d) (5 point) Yes</li>

</ul>

Answer:

Figure 2: Question2.

(a) No. Assume it can be the structure of a red-black tree. Noted The root node is black.

Let the left child be red. since the invariant 5, every path from a root node to a NULL node has the same number of black nodes. The right path has 0 black nodes. therefore, all of its descendants are red. But, it violated the invariant 4. So, the left child cannot be red.

Let the left child be black. Since the invariant 5, we can know that the other two of its descendants must be red to maintain the invariant 5, because, the right path has 0 black nodes. But, it violated the invariant 4. So, the left child cannot be black. The same logistics for the right child.

In sum, there is a contradiction. Thus, it cannot be the structure of a red-black tree. (b) Yes. (c) Yes. (d) Yes.

<ol start="3">

 <li><strong>Binary search tree with equal keys. </strong>(30 points + 10 bonus points) In the class, we assumed that all the keys in a BST are different from each other. However, the BST can still store keys of the same value, in this case, we put a key that is less than a node to its left, and put a key that is greater than <strong>or equal to </strong>a node to its right. Here is the algorithm for inserting a new key <em>z </em>in to a binary search tree <em>T</em>:</li>

</ol>

<strong>Algorithm 1: </strong>Tree-Insert(<em>T,z</em>)

<ul>

 <li>y = NIL;</li>

 <li>x = T.root;</li>

 <li><strong>while </strong>x 6= NIL</li>

 <li>y=x;</li>

 <li><strong>if </strong>key<em>&lt;</em>x.key</li>

 <li>x = x.left;</li>

 <li><strong>else </strong>x = x.right</li>

 <li>parent = y;</li>

 <li><strong>if </strong>y==NIL</li>

 <li>root = z; //tree T was empty</li>

 <li><strong>elseif </strong>key<em>&lt;</em>y.key</li>

 <li>left=z;</li>

 <li><strong>else </strong>right=z;

  <ul>

   <li>(10 points) To better understand the algorithm, draw the tree generated by inserting the numbers 5, 3, 10, 8, 12, 12, 8, 8, 6, 6, 7, 5, 8 in this given order into an initially empty binary search tree using the above algorithm.</li>

   <li>(10 points) What is the asymptotic runtime of Tree-Insert when used to insert <em>n </em>items with identical keys into an initially empty binary search tree?</li>

  </ul></li>

</ul>

We propose to improve Tree-Insert by testing before line 5 to determine whether z.key==x.key and by testing before line 11 to determine whether z.key==y.key. If equality holds, we implement one of the following strategies. For each strategy, find the asymptotic runtime of inserting <em>n </em>items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, in which we compare the keys of z and x, and substitute y for x to arrive at the strategies for line 11.)

Figure 3: Question3 (a).

Question3 (b) Answer:

Acording to the Algorithm 1, we know that TREE-INSERT is always FALSE on line 5, then the right child will be chosen. For the line 11, the TREE-INSERT is also FALSE, the new element will be inserted to the right of the rightmost leaf. As we know, there are total n items, so the height of tree is n, and increases at every insertion and new element is inserted as a new leaf node. Therefore, the runtime of TREE-INSERT is

<ul>

 <li>(10 points) Keep a list of nodes with equal keys at x, and insert z into the list.</li>

</ul>

Answer:

When we keep a list of nodes with equal keys at x, and insert z into the list, which means the height of the tree is 0, so we only take linear time. It is a single insertion into a list, so runtime is <em>O</em>(1).

<ul>

 <li>(10 bonus points) Randomly set x to either x.left or x.right. (Give the worst-case runtime and informally derive the expected runtime.) Answer:</li>

</ul>

The worst-case: it would set all x to left or all x to right.So it is same as the part (b), the runtime is <em>O</em>(<em>n</em><sup>2</sup>).

The expected: we expect the tree is a balance tree, like half-half, set half x to x.left, half to x.right. Therefore, the height of the tree is log<em>n</em>, the total runtime is

[<strong>Note: for (b) (c) and (d), we are expecting the runtime represented as a function of </strong><em>n</em>].

<ol start="4">

 <li><strong>Hat-check problem. </strong>(10 bonus points) Use indicator random variables to solve the following problem, which is known as the hat-check problem. Each of <em>n </em>customers gives</li>

</ol>

a hat to a hat-check person at a restaurant. The hat-check person gives the hats back to the customers in a random order. What is the expected number of customers who get back their own hat?

Answer: Using indicator random variables let ith customers get back their own hat back.

<em>Xi </em>= <em>I </em>(for 1 ≤ <em>i </em>≤ <em>n </em>)

Let X be a random variable denoting the total number of customers who get their own hat back.

Then, we are going to compute the E[X].

We know that the hat-check person gives the hats back to the customers in a random order, so each of n customers has the probability 1/n to get their own hat back.

So,<em>E</em>[<em>Xi</em>] = 1<em>/n</em>

<em>E</em>[<em>X</em>] = <em>E</em>[<sup>P</sup><em><sup>n</sup></em><em><sub>i</sub></em><sub>=1 </sub><em>Xi</em>]

<em>E</em>[<em>X</em>] = <sup>P</sup><em><sup>n</sup></em><em><sub>i</sub></em><sub>=1 </sub><em>E</em>[<em>Xi</em>]

<em>E</em>[<em>X</em>] = <sup>P</sup><em><sup>n</sup></em><em><sub>i</sub></em><sub>=1</sub>(1<em>/n</em>)

<em>E</em>[<em>X</em>] = 1

Thus, the expected number of customers which get their own hat back is 1.

<ol start="5">

 <li><strong>Quicksort with equal element values. </strong>(30 points) The analysis of the expected running time of randomized Quicksort in class (corresponding to Section 7.4.2 in textbook) assumes that all element values are distinct. In this problem, we examine what happens when they are not, i.e., there exist same-valued elements in the array to be sorted.</li>

</ol>

The Quicksort algorithm relies on the following partition algorithm, which finds a pivot randomly, and then put all the numbers less than or equal to the pivot in the left, and put all the numbers greater than the pivot in the right, and then return the pivot location, as well as the left and right sublists for recursive calls.

<strong>Algorithm 2: </strong>Partition(<em>A,p,r</em>)

<ul>

 <li>q=Random(p,r); //generate a random number in the range of [p,r]</li>

 <li>L=empty list, R=empty list; 3 <strong>for each </strong>element a in A except A[q]:</li>

 <li><strong>if </strong>a≤A[q]:</li>

 <li>append a to L;</li>

 <li><strong>else </strong>append a to R;</li>

 <li>A=append(L,A[q],R);</li>

 <li><strong>returen </strong>A, q;</li>

</ul>

In this algorithm, the list to be sorted is <em>A</em>, and we use <em>p </em>and <em>r </em>to denote the left-most and right-most indices of the currently processing subarray, respectively. For example, in the initial call of the Quicksort algorithm, we will let <em>p </em>= 0 and <em>r </em>= <em>n</em>−1, which correspond to the whole original array. The Partition(<em>A,p,r</em>) procedure returns an index <em>q </em>such that each element of <em>A</em>[<em>p </em>: <em>q </em>− 1] is less than or equal to <em>A</em>[<em>q</em>] and each element of <em>A</em>[<em>q </em>+ 1 : <em>r</em>] is greater than <em>A</em>[<em>q</em>].

<ul>

 <li>(10 points) Suppose there are <em>n </em>elements and all element values are equal. What would be randomized Quicksort’s running time in this case?</li>

</ul>

Answer:

Noted there are <em>n </em>elements and all the element values are equal. Therefore, the random value p and r are always equal.According to the Algorithm 2, we know that all the element will go to the L (left empty list). the total runtime is

<ul>

 <li>(10 points) Modify the Partition procedure to produce a procedure Partition<sup>0</sup>(<em>A,p,r</em>), which permutes the elements of <em>A</em>[<em>p </em>: <em>r</em>] and returns two indices <em>q </em>and <em>t</em>, where <em>p </em>≤ <em>q </em>≤ <em>t </em>≤ <em>r</em>, such that:

  <ol>

   <li>all elements of <em>A</em>[<em>q </em>: <em>t</em>] are equal,</li>

   <li>each element of <em>A</em>[<em>p </em>: <em>q </em>− 1] is less than <em>A</em>[<em>q</em>], and</li>

  </ol></li>

</ul>

<ul>

 <li>each element of <em>A</em>[<em>t </em>+ 1 : <em>r</em>] is greater than <em>A</em>[<em>q</em>]</li>

</ul>

Like Partition, your Partiton<sup>0 </sup>procedure should take <em>O</em>(<em>r </em>− <em>p</em>) time.

Answer:

PARTITION’(A, p, r) x = A[p] low = p, high = p for(<em>j </em>= <em>p </em>+ 1<em>,j &lt;</em>= <em>r,j </em>+ +) if <em>A</em>[<em>j</em>] <em>&lt; x </em>y = A[j]; A[j] = A[high + 1];

A[high + 1] = A[low]; A[low] = y; low++, high++; END IF

else if (A[j] == x) exchange A[high + 1] with A[j]; high++;

END IF

END FOR;

return (low, high);

(c) (10 points) Now you have a Partition<sup>0</sup>(<em>A,p,r</em>) algorithm, based on this algorithm, provide the pseudocode of a Quicksort<sup>0</sup>(<em>A</em>) algorithm which calls Partition<sup>0</sup>(<em>A,p,r</em>) as a subroutine, so that it recurses only on partitions of elements not known to be equal to each other. [Hint: it will looks very similar to our Quicksort pseudocode in the lecture slides, you only need to make minor modifications to recurse on the partitions produced by Partition<sup>0</sup>(<em>A,p,r</em>).] Answer:

QUICKSORT’(A, p, r) if (<em>p &lt; r</em>)

(low, high) = RANDOMIZED-PARTITION’(A, p, r);

QUICKSORT’(A, p, low – 1);

QUICKSORT’(A, high + 1, r);

END IF;